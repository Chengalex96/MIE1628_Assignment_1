# -*- coding: utf-8 -*-
"""MapReduce(k=6).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w_gHOabWccAcY-1PQ8jgEcyaPvHSlyek
"""

#!/usr/bin/env python
"""mapper.py"""

import sys
from math import sqrt

"""get initial centroids from a txt file and add them in an array"""

def getCentroids(filepath):
    global x_list
    global y_list
    global x_initial
    global y_initial

    '''
    Mapper function:
        load in coordinates, Centroid, 
        Calculate the distances from each sample to each centroid point
        output relabeled cluster ID as key, Coordinates as value.
    
    '''
    with open('initial6points.txt') as a:
      initial = a.readlines()

    initial = list(map(lambda s: s.strip(), initial))
    x_initial = []
    y_initial = []
    for line in initial:
        Type = line.split(',')
        x = Type[0]
        y = Type[1]
        x_initial.append(x)
        y_initial.append(y)
    
    with open('data_points-1.txt') as f:
      lines = f.readlines()
      
    x_list = []
    y_list = []

    for line in lines:
        Type = line.split(',')
        x = Type[0]
        y = Type[1]
        x_list.append(x)
        y_list.append(y)
      
    x_initial = [float(x) for x in x_initial]
    y_initial = [float(x) for x in y_initial]
    x_list = [float(x) for x in x_list]
    y_list = [float(x) for x in y_list]

    centroids = []
    return centroids

k = 6

"""create clusters based on initial centroids"""

def createClusters(centroids):
  distance = []
  cluster = []
  for i in range (k):
    for j in range (len(x_list)):
      distancestep = sqrt((x_list[j] - x_initial[i])**2 + (y_list[j] - y_initial[i])**2)
      distance.append(distancestep)
      if(i == 5):
        if(distance[j] <= min(distance[j+len(x_list)], distance[j+2*len(x_list)], distance[j+3*len(x_list)], distance[j+4*len(x_list)], distance[j+5*len(x_list)])):
          cluster.append(0)
        elif(distance[j+len(x_list)] <= min(distance[j], distance[j+2*len(x_list)], distance[j+3*len(x_list)], distance[j+4*len(x_list)], distance[j+5*len(x_list)])):
          cluster.append(1)
        elif(distance[j+2*len(x_list)] <= min(distance[j], distance[j+len(x_list)], distance[j+3*len(x_list)], distance[j+4*len(x_list)], distance[j+5*len(x_list)])):
          cluster.append(2)
        elif(distance[j+3*len(x_list)] <= min(distance[j], distance[j+len(x_list)], distance[j+2*len(x_list)], distance[j+4*len(x_list)], distance[j+5*len(x_list)])):
          cluster.append(3)
        elif(distance[j+4*len(x_list)] <= min(distance[j], distance[j+len(x_list)], distance[j+2*len(x_list)], distance[j+3*len(x_list)], distance[j+4*len(x_list)])):
          cluster.append(4)
        else:
          cluster.append(5)
  return cluster

"""On MapReduce (Mapper function), this would return the data points with the closest centroid (0, 1, or 2) attached with the data points.

**Calculating New centroids**
"""

def NewClusters(Cluster_list):

  global cluster_change

  xsum0 = 0
  ysum0 = 0
  count0 = 0
  xsum1 = 0
  ysum1 = 0
  count1 = 0
  xsum2 = 0
  ysum2 = 0
  count2 = 0
  xsum3 = 0
  ysum3 = 0
  count3 = 0
  xsum4 = 0
  ysum4 = 0
  count4 = 0
  xsum5 = 0
  ysum5 = 0
  count5 = 0
  
  clusterx = []
  clustery = []
  cluster1x = []
  cluster1y = []
  cluster2x = []
  cluster2y = []
  cluster3x = []
  cluster3y = []
  cluster4x = []
  cluster4y = []
  cluster5x = []
  cluster5y = []

  for i in range (len(Cluster_list)):
    if(Cluster_list[i] == 0):
      xsum0 = xsum0 + x_list[i]
      ysum0 = ysum0 + y_list[i]
      count0 = count0 + 1
      clusterx.append(x_list[i])
      clustery.append(y_list[i])
    if(Cluster_list[i] == 1):
      xsum1 = xsum1 + x_list[i]
      ysum1 = ysum1 + y_list[i]
      count1 = count1 + 1
      cluster1x.append(x_list[i])
      cluster1y.append(y_list[i])
    if(Cluster_list[i] == 2):
      xsum2 = xsum2 + x_list[i]
      ysum2 = xsum2 + x_list[i]
      count2 = count2 + 1
      cluster2x.append(x_list[i])
      cluster2y.append(x_list[i])
    if(Cluster_list[i] == 3):
      xsum3 = xsum3 + x_list[i]
      ysum3 = xsum3 + x_list[i]
      count3 = count3 + 1
      cluster3x.append(x_list[i])
      cluster3y.append(x_list[i])
    if(Cluster_list[i] == 4):
      xsum4 = xsum4 + x_list[i]
      ysum4 = xsum4 + x_list[i]
      count4 = count4 + 1
      cluster4x.append(x_list[i])
      cluster4y.append(x_list[i])
    if(Cluster_list[i] == 5):
      xsum5 = xsum5 + x_list[i]
      ysum5 = xsum5 + x_list[i]
      count5 = count5 + 1
      cluster5x.append(x_list[i])
      cluster5y.append(x_list[i])
  plt.scatter(clusterx, clustery)
  plt.scatter(cluster1x, cluster1y)
  plt.scatter(cluster2x, cluster2y)
  plt.scatter(cluster3x, cluster3y)
  plt.scatter(cluster4x, cluster4y)
  plt.scatter(cluster5x, cluster5y)  
  plt.scatter(x_initial, y_initial)
  plt.show()
  print("Figure")

  NewX0 = xsum0 / count0
  NewY0 = ysum0 / count0
  NewX1 = xsum1 / count1
  NewY1 = ysum1 / count1
  NewX2 = xsum2 / count2
  NewY2 = ysum2 / count2
  NewX3 = xsum3 / count3
  NewY3 = ysum3 / count3
  NewX4 = xsum4 / count4
  NewY4 = ysum4 / count4
  NewX5 = xsum5 / count5
  NewY5 = ysum5 / count5

  cluster_change = abs(x_initial[0] - NewX0) + abs(x_initial[1] - NewX1) + (x_initial[2] - NewX2) + abs(y_initial[0] - NewY0) +abs(y_initial[1] - NewY1) +abs(y_initial[2] - NewY2) + abs(x_initial[3] - NewX3) + abs(x_initial[4] - NewX4) + (x_initial[5] - NewX5) + abs(y_initial[3] - NewY3) +abs(y_initial[4] - NewY4) +abs(y_initial[5] - NewY5) 
  print(cluster_change)

  NewX0 = str(NewX0)
  NewY0 = str(NewY0)
  NewX1 = str(NewX1)
  NewY1 = str(NewY1)
  NewX2 = str(NewX2)
  NewY2 = str(NewY2)
  NewX3 = str(NewX3)
  NewY3 = str(NewY3)
  NewX4 = str(NewX4)
  NewY4 = str(NewY4)
  NewX5 = str(NewX5)
  NewY5 = str(NewY5)

  NewCent = "{},{}\n{},{}\n{},{}\n{},{}\n{},{}\n{},{}".format(NewX0, NewY0, NewX1, NewY1, NewX2, NewY2, NewX3, NewY3, NewX4, NewY4, NewX5, NewY5)
  file='initial6points.txt' 
  with open(file, 'w') as filetowrite:
      filetowrite.write(NewCent)
  print(NewCent)

"""On MapReduce (Reducer Function), this will return the new centroid positions and will edit the existing text file.

This function will loop the map and reducer function until iterations or criteria are met
"""

import matplotlib.pyplot as plt
import timeit
start = timeit.default_timer()
i = 0
cluster_change = 100000000
while i < 10 and cluster_change > 2:
  centroids = getCentroids('initial6points.txt')
  Cluster_list = createClusters(centroids)
  print("Rep #:" )
  print(i + 1)
  NewClusters(Cluster_list)
  i = i + 1

stop = timeit.default_timer()
print('Time: ', stop - start)